// =========================== Configurables for deployers

udf_prefix <- 'ivo_';  // additional prefixes to be added here

// ============================ The Grammar's root symbol

query_specification <-
	with_clause? _
	query_expression _ EOF;

// ============================ Top level query parts

with_clause <-
	'WITH' _ with_query
		_ (','_ with_query )*;

with_query <- identifier __ as
	_ '(' _ query_expression _ ')';

// Rewriting query_expression to have set operator syntax like
// postgres.
query_expression <-
	select_query
	(__ set_operator
	__ set_query_expression)*;

set_operator <-
	('EXCEPT' / 'INTERSECT' / 'UNION') 
	(__ 'ALL')?;

set_query_expression <-
	query_expression 
	/ '(' _ query_expression _ ')';

// The SELECT clause itself

select_query <-
	_ 'SELECT'
	(__ set_quantifier)?
	(_ set_limit)?
	_ select_list
	_ table_expression;

set_quantifier <-
	('DISTINCT' / 'ALL') _a;

set_limit <-
	'TOP' __ unsigned_integer;


// ================================= Select lists and their items
select_list	<-
	'*' 
	/ select_sublist (_ ',' _ select_sublist)*;

select_sublist <-
	table_name _ '.' _ '*'
	/ derived_column;

derived_column <- value_expression _ as_clause?;

// Table expressions (FROM clause: tables, join, etc.)

table_expression <-
	from_clause
	(_ where_clause)?
	(_ group_by_clause)?
	(_ order_by_clause)?
	(_ offset_clause)?;

from_clause <-
	'FROM' __ from_list;

from_list <-
	table_reference 
	(_ ',' _ table_reference)*;

// joining correlation_specification and as_clause
as_clause <-
	as? _ identifier;

table_reference <-
	joined_table 
	/ subquery _ as_clause
	/ table_name as_clause?;

// JOIN clause and related elements

joined_table <-
	qualified_join
	/ sub_join;

sub_join <-
	'(' _ joined_table _ ')';

join_opener <-
	sub_join 
	/ table_name as_clause?
	/ subquery _ as_clause;

qualified_join <-
	join_opener _ join_clause;

subquery <-
	'(' _ query_expression _ ')';

join_clause <-
	join_method? _ join _ 
	table_reference (_ join_specification)? 
	(_ (sub_join / join_clause))*;

join_type <-
	('INNER'
	/ (outer_join_type _)? 'OUTER') _a;

outer_join_type <-
	('LEFT' / 'RIGHT' / 'FULL') _a;

join_method	<-
	natural? _ (join_type)?;

join_specification	<-
	join_condition
	/ named_columns_join;

join_condition <-
	on _ search_condition;

named_columns_join <-
	'USING' _ '('
	_ identifier (_ ',' _ identifier)*
	_ ')';

// WHERE clause and related elements

where_clause <-
	where _ search_condition;

search_condition <- 
	boolean_term _ (or _ boolean_term)*;

boolean_term <-
	boolean_factor _ (and _ boolean_factor)*;

predicate <-
	comparison_predicate 
	/ between_predicate
	/ in_predicate
	/ like_predicate 
	/ null_predicate 
	/ exists_predicate;

boolean_factor <-
	('NOT')? boolean_primary;

boolean_primary <-
	'(' search_condition ')'
	/ predicate;

null_predicate <-
	'IS' (__ 'NOT')? 
	__ ('TRUE' / 'FALSE' / 'UNKNOWN' / 'NULL');

comparison_predicate <-
	value_expression comp_op value_expression;

like_predicate <-
	character_value_expression
	_ not? _ ('ILIKE' / 'LIKE')
	_ character_value_expression;

comp_op <-
	'=' / '!=' / '<=' / '>=' / '>' / '<';

between_predicate <-
	('NOT' __)? between
	_ value_expression _ and _ value_expression;

in_predicate <-
	('NOT' __)? 'IN'
	__ in_predicate_value;

in_predicate_value <-
	identifier
	/ '(' value_expression (_ ',' _  value_expression)* ')'
	/ '(' query_expression ')';

exists_predicate <-
	('NOT' __)? 'EXISTS' __ subquery;

order_by_clause <-
	'ORDER BY' __ order_by_list;

order_by_list <-
	order_by_term
	(_ ',' _ order_by_term)*;

order_by_term <-
	order_by_expression (__ order_by_direction)?;

order_by_expression <-
	identifier
	/ unsigned_integer;

order_by_direction <-
	'ASC'
	/ 'DESC';

// HAVING clause depends on GROUP BY
group_by_clause <-
	'GROUP BY' __ group_by_term_list
	(__ having_clause)?;

group_by_term_list <-
	identifier (_ ',' _ identifier)*;

having_clause <-
	'HAVING' __  // XXX: ensure balanced parens!
	'('? search_condition ')'?;

offset_clause <-
	'OFFSET' __ unsigned_integer;

// Identifiers (<schema>.<table>.<field>), numerical / geometrical 
// / string expressions and functions

table_name <-
	identifier (_ '.' _ identifier)? (_ '.' _ identifier)?;

// we don't re-use table_name here since PEG uses greedy matching
// and thus would parse x.a all as a table name.  Thus, for 
// column_reference we simply allow 1..4 identifiers.
column_reference <-
	(identifier _ '.' _)? (identifier _ '.' _)? (identifier _ '.' _)? identifier;

identifier <-
	(regular_identifier / delimited_identifier);

delimited_identifier <-
	'"' ('""' / r'[^"]')+ '"';

regular_identifier <-
	(!(keyword) letter (letter / digit / '_')*);

character_string_literal <-
	("'" ("''" / r"[^']")* "'" (Space+ comment _)*)+;

fold_function <-	
	('UPPER'/'LOWER') _ '(' character_value_expression ')';

string_value_function <-
	string_geometry_function
	/ fold_function
	/ user_defined_function;
	
character_primary <-
	character_string_literal 
	/ string_value_function
	/ value_expression_primary;

concatenation <-
	character_primary
	_ '||' 
	_ character_value_expression;

geometry_function <-
	geometry_value_function
	/ non_predicate_geometry_function
	/ predicate_geometry_function
	/ region
	/ extract_coord_sys;

bitwise_op <-
	'&' / '|' / '^';

bitwise_expression <-
	'~' numeric_value_expression
	/ numeric_value_expression
	_ bitwise_op
	_ numeric_value_expression;

string_value_expression <-
	character_value_expression;

character_value_expression <-
	concatenation
	/ column_reference
	/ character_primary;

geometry_value_function <-
	box
	/ centroid
	/ circle
	/ point
	/ polygon
	/ region 
	/ user_defined_function;

coordinates <-
	numeric_value_expression _ ','
	_ numeric_value_expression;

box <-
	'BOX' '(' (
	_ character_string_literal ',')? 
	_ coordinates _ ',' 
	_ numeric_value_expression _ ',' 
	_ numeric_value_expression _ ')';

centroid <-
	'CENTROID' '(' 
	_ geometry_value_expression _ ')';

circle <-
	'CIRCLE' '(' 
	_ string_value_expression _ ','
	_ coordinates _ ','
	_ numeric_value_expression _ ')';

polygon <-
	'POLYGON' '(' 
	_ string_value_expression _ ','
	_ coordinates _ ','
	_ coordinates _ 
	(_ ',' _ coordinates)* _ ')';

non_predicate_geometry_function <-
	area
	/ coord1
	/ coord2
	/ distance;

area <-
	'AREA' '(' 
	_ geometry_value_expression 
	_ ')';

coord1 <-
	'COORD1' '('
	_ coord_value 
	_ ')';

coord2 <-
	'COORD2' '('
	_ coord_value
	_ ')';

coord_value <-
	point /
	column_reference;

distance <-
	'DISTANCE' '(' _
	coord_value _ ','
	_ coord_value _ ')';

predicate_geometry_function <-
	contains
	/ intersects;

contains <-
	'CONTAINS' '(' 
	_ geometry_value_expression _ ',' 
	_ geometry_value_expression _ ')';

intersects <-
	'INTERSECTS' '(' 
	_ geometry_value_expression _ ','
	_ geometry_value_expression _ ')';

region <-
	'REGION' '(' _  string_value_expression _ ')';

extract_coord_sys <-
	'COORDSYS' '(' _ geometry_value_expression _ ')';

string_geometry_function <-
	extract_coord_sys 
	/ user_defined_function;

math_function <-
	(onetwo_param_math '('
	_ numeric_value_expression (_ ',' _ signed_integer)? 
	_ ')')
	/ (two_param_math '(' 
	_  numeric_value_expression _ ',' 
	_ numeric_value_expression _')')
	/ (one_param_math '(' _ numeric_value_expression _ ')')
	/ rand_function
	/ (no_param_math '()');

trig_function <-
	(two_param_trig '(' 
	_  numeric_value_expression _ ',' 
	_ numeric_value_expression _')')
	/ (one_param_trig '(' 
	_ numeric_value_expression _ ')');

// No params
no_param_math <-
	'PI';

// One param
one_param_trig <-
	'ACOS' / 'ASIN' / 'ATAN' / 'COS' / 
	'COT' / 'SIN' / 'TAN';

one_param_math <-
	'ABS' / 'CEILING' / 'DEGREES' / 'EXP' / 
	'FLOOR' / 'LOG10' / 'LOG' / 'RADIANS' / 
	'SQRT';

// Two param
two_param_math <-
	'MOD' / 'POWER';

two_param_trig <-
	'ATAN2';

onetwo_param_math <-
	'ROUND' / 'TRUNCATE';

rand_function <-
	'RAND' '(' (_ numeric_value_expression _)? ')';

string_function <-
	string_func_name '(' _ value_expression _ ')';

string_func_name <-
	'LOWER';

set_function_specification <-
	'COUNT' '(' ('*' / 
	(set_quantifier __)? identifier) ')' 
	/ general_set_function;

set_function_type <-
	'AVG' / 'MAX' / 'MIN' / 'SUM';

general_set_function <-
	set_function_type '(' 
	set_quantifier? numeric_value_expression ')';

point <-
	'POINT' '('
	_ (string_value_expression / 'NULL') 
	_ ',' _ coordinates _ ')';

numeric_value_expression <-
	term (_ ('+' / '-') _ numeric_value_expression)*;

term <-
	factor (_ ('*' / '/') _ term)*;

factor <-
	('+' / '-')? numeric_primary;

numeric_value_function <-
	math_function
	/ trig_function
	/ numeric_geometry_function
	/ user_defined_function;

numeric_geometry_function <-
	predicate_geometry_function
	/ non_predicate_geometry_function;

udf_name <- udf_prefix regular_identifier;

user_defined_function <-
	udf_name '(' 
	(_ value_expression (_ ',' _ value_expression)* _)?  
	')';

numeric_primary	<-
	value_expression_primary
	/ numeric_value_function;

// This is required as a helper for value_expression (and yes,
// character-valued column references will be numeric_value_expressions
// by this grammar; there is no way around this on the grammar level.
character_value_expression_noid <-
	concatenation;

// value_expression *really* needs a longest-alternative functionality
// (or we'd have to re-write it with look-ahead on the operator).
// As is, we just make sure string_value_expression_noid won't match
// identifier, which should *just* work to keep the PEG engine
// from prematurely committing to s_v_e
value_expression <-
	character_value_expression_noid
	/ numeric_value_expression
	/ geometry_value_expression;

// TODO: value_expression_primary (as in the BNF) is unnecessarily wide
// here ("CENTROID(3)")
geometry_value_expression <-
	value_expression_primary
	/ geometry_value_function;

value_expression_primary <-
	unsigned_literal
	/ column_reference
	/ set_function_specification
	/ '(' value_expression ')';

scientific_number <-
	exact_numeric_literal 'E' 
	('+' / '-')? unsigned_integer;

exact_numeric_literal	<-
	(unsigned_integer '.')* unsigned_integer;

signed_integer <-
	('+' / '-')? unsigned_integer;

// TODO: We should take out character_string_literal here, MD thinks --
// what sort of use case did people have in mind here?
// "POINT('ICRS',X,'SY')"

unsigned_literal <-
	unsigned_numeric_literal
	/ character_string_literal;

unsigned_numeric_literal <- 
	scientific_number 
	/ exact_numeric_literal;

numeric_primary <-
	value_expression_primary
	/ numeric_value_function;

unsigned_integer <-
	digit+;

unsigned_hexadecimal <-
	'0x' hex_digit+;

digit <-
	r'[0-9]';

hex_digit <-
	r'[0-9A-F]';

letter <-
	r'[a-zA-Z]';

// Reserved words

as <- 'AS' _a;

on <- 'ON' _a;

join <- 'JOIN' _a;

natural <- 'NATURAL' _a;

between <- 'BETWEEN' _a;

and <- 'AND' _a;

or <- 'OR' _a;

not <- 'NOT' _a;

where <- 'WHERE' _a;

keyword <-
	(ADQL_reserved_word / SQL_reserved_word) _a;

ADQL_reserved_word <-
	'ABS' / 'ACOS' / 'AREA' / 'ASIN' / 'ATAN2'
	/ 'ATAN' / 'BIT_AND' / 'BIT_NOT' / 'BIT_OR'
	/ 'BIT_XOR' / 'BOX' / 'CEILING' / 'CENTROID' 
	/ 'CIRCLE' / 'CONTAINS' / 'COORD1' / 'COORD2'
	/ 'COORDSYS' / 'COS' / 'DEGREES' / 'DISTANCE' 
	/ 'EXP' / 'FLOOR' / 'ILIKE' / 'INTERSECTS'
	/ 'IN_UNIT' / 'LOG10' / 'LOG' / 'MOD' 
	/ 'PI' / 'POINT' / 'POLYGON' / 'POWER'
	/ 'RADIANS' / 'REGION' / 'RAND' / 'ROUND'
	/ 'SIN' / 'SQRT' / 'TOP' / 'TAN' / 'TRUNCATE';

SQL_reserved_word <-
	'ABSOLUTE' / 'ACTION' / 'ADD' / 'ALL' / 'ALLOCATE'
	/ 'ALTER' / 'AND' / 'ANY' / 'ARE' / 'AS'
	/ 'ASC' / 'ASSERTION' / 'AT' / 'AUTHORISATION'
	/ 'AVG' / 'BEGIN' / 'BIT' / 'BIT_LENGTH' / 'BOTH'
	/ 'BY' / 'CASCADE' / 'CASCADED' / 'CASE' / 'CAST'
	/ 'CATALOG' / 'CHAR' / 'CHARACTER' / 'CHAR_LENGTH'
	/ 'CHARACTER_LENGTH' / 'CHECK' / 'CLOSE' / 'COALESCE'
	/ 'COLLATE' / 'COLLATION' / 'COLUMN' / 'COMMIT'
	/ 'CONNECT' / 'CONNECTION' / 'CONSTRAINT' 
	/ 'CONSTRAINTS' / 'CONTINUE' / 'CONVERT'
	/ 'CORRESPONDING' / 'COUNT' / 'CREATE' / 'CROSS'
	/ 'CURRENT' / 'CURRENT_DATE' / 'CURRENT_TIME'
	/ 'CURRENT_TIMESTAMP' / 'CURRENT_USER' / 'CURSOR'
	/ 'DATE' / 'DAY' / 'DEALLOCATE' / 'DECIMAL'
	/ 'DECLARE' / 'DEFAULT' / 'DEFERRABLE' / 'DEFERRED'
	/ 'DELETE'/ 'DESC' / 'DESCRIBE' / 'DESCRIPTOR'
	/ 'DIAGNOSTICS' / 'DISCONNECT' / 'DISTINCT' / 'DOMAIN'
	/ 'DOUBLE' / 'DROP' / 'ELSE' / 'END' / 'END-EXEC'
	/ 'ESCAPE' / 'EXCEPT' / 'EXCEPTION' / 'EXEC'
	/ 'EXECUTE' / 'EXISTS' / 'EXTERNAL' / 'EXTRACT'
	/ 'FALSE' / 'FETCH' / 'FIRST' / 'FLOAT' / 'FOR'
	/ 'FOREIGN' / 'FOUND' / 'FROM' / 'FULL' / 'GET'
	/ 'GLOBAL' / 'GO' / 'GOTO' / 'GRANT' / 'GROUP'
	/ 'HAVING' / 'HOUR' / 'IDENTITY' / 'IMMEDIATE'
	/ 'IN' / 'INDICATOR' / 'INITIALLY' / 'INNER'
	/ 'INPUT' / 'INSENSITIVE' / 'INSERT' / 'INT'
	/ 'INTEGER' / 'INTERSECT' / 'INTERVAL' / 'INTO'
	/ 'IS' / 'ISOLATION' / 'JOIN' / 'KEY' / 'LANGUAGE'
	/ 'LAST' / 'LEADING' / 'LEFT' / 'LEVEL'
	/ 'LIKE' / 'ILIKE' / 'LOCAL' / 'LOWER' / 'MATCH'
	/ 'MAX' / 'MIN' / 'MINUTE' / 'MODULE'
	/ 'MONTH' / 'NAMES' / 'NATIONAL' / 'NATURAL'
	/ 'NCHAR' / 'NEXT' / 'NO' / 'NOT' / 'NULL'
	/ 'NULLIF'/ 'NUMERIC' / 'OCTET_LENGTH' / 'OFFSET'
	/ 'OF' / 'ON' / 'ONLY' / 'OPEN' / 'OPTION' / 'OR'
	/ 'ORDER' / 'OUTER' / 'OUTPUT' / 'OVERLAPS' / 'PAD'
	/ 'PARTIAL' / 'POSITION' / 'PRECISION' / 'PREPARE'
	/ 'PRESERVE' / 'PRIMARY' / 'PRIOR' / 'PRIVILEGES'
	/ 'PROCEDURE' / 'PUBLIC' / 'READ'
	/ 'REAL' / 'REFERENCES' / 'RELATIVE' / 'RESTRICT'
	/ 'REVOKE' / 'RIGHT' / 'ROLLBACK' / 'ROWS'
	/ 'SCHEMA' / 'SCROLL' / 'SECOND' / 'SELECT' / 'SECTION'
	/ 'SESSION_USER' / 'SET' / 'SIZE' / 'SMALLINT' / 'SOME'
	/ 'SPACE' / 'SQL' / 'SQLCODE' / 'SQLERROR' / 'SQLSTATE'
	/ 'SUBSTRING' / 'SUM' / 'SYSTEM_USER' / 'TABLE' 
	/ 'TEMPORARY' / 'THEN' / 'TIME' / 'TIMESTAMP'
	/ 'TIMEZONE_HOUR' / 'TIMEZONE_MINUTE' / 'TO' / 'TRAILING'
	/ 'TRANSACTION'/ 'TRANSLATE' / 'TRANSLATION' / 'TRIM'
	/ 'TRUE' / 'UNION' / 'UNIQUE' / 'UNKNOWN' / 'UPDATE'
	/ 'UPPER' / 'USAGE' / 'USER' / 'USING' / 'VALUE'
	/ 'VALUES' / 'VARCHAR' / 'VARYING' / 'VIEW' / 'WHEN'
	/ 'WHENEVER' / 'WHERE' / 'WITH' / 'WORK' / 'WRITE' 
	/ 'YEAR' / 'ZONE';

// Auxiliary rules to handle things like whitespace and comments

ANY_CHAR <-
	letter / digit / ' ' / '\t' / ',' / ';' / '.';

comment	<-
	'--' r'[^\n\r]*';

_ <-
	(comment / Space / EOL)*;

__ <-
	(comment / Space / EOL)+;

_a <-
	!r'[A-Z0-9_]';

Space <-
	' '+ / '\t';

EOL <-
	'\r\n' / '\n' / '\r';
